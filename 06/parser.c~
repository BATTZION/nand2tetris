#include <stdio.h>
#include <stdlib.h>
#include "parser.h"
#include <string.h>
#include <malloc.h>
#include "hashtable.h"

char *strrev(char *str)  
{  
      char *p1, *p2;  
  
      if (! str || ! *str)  
            return str;  
      for (p1 = str, p2 = str + strlen(str) - 1; p2 > p1; ++p1, --p2) {  
            *p1 ^= *p2;  
            *p2 ^= *p1;  
            *p1 ^= *p2;  
      }  
      return str;  
}
void translate(int num,char s[])
{
	int i=0;
	while(num){
		*(s+i)=num % 2 + '0';
		num /=2;
		i++;
	}
	while(i<MAX_CODE_LEN-1)
	s[i++]='0';
	s[i]=0;
	strrev(s);
}
int is_number(char s[])
{
	int i=0,flage=1;
	while(s[i]!='\0' && s[i]!='\r' && s[i]!='\n')
	  if(s[i]<'0'||s[i]>'9'){
        flage=0;
		break;
	  }
	  else
		i++;
	return flage;
}
COMMAND_TYPE commandType(char string[])
{
	char *p = string;
	if(p[0]=='@')
	  return A_COMMAND;
	else if(p[0]=='(')
	  return L_COMMAND;
	else if(p[0]=='/' && p[1]=='/')
	  return ANNOTATION;
	else
	  return C_COMMAND;
}
char *symbol(char p[])
{
	char *s;
	int i=1,num=0,j=0;
	s=(char *)malloc(MAX_CODE_LEN*sizeof(char));
	if(p[0]=='@'){
		while(p[i]==' ')
		  i++;
		while(p[i]!='\n'&& p[i]!='\r')
		  if(p[i]!=' ')
			s[j++]=p[i++];
		  else
			i++;
		s[j]=0;
		i=0;
		num=atoi(s);
		if(is_number(s)==0)
		  return s;
		else
		  translate(num,s);
	}
	else{
		while(p[i]==' ')
		  i++;
		while(p[i]!=')')
		  if(p[i]!=' ')
			s[j++]=p[i++];
		  else
			i++;
		s[j]=0;
	}
	return s;
}
char *dest(char p[])
{
	char *s;
	int i=0;
	s=(char *)malloc(MAX_DEST_LEN * sizeof(char));
	for(i=0;p[i] != '=' && p[i]!= ' '; i++)
	  s[i]=p[i];
	s[i]='\0';
	return s;
}
char *comp(char p[])
{
	char *s;
	int i=0,j=0;
	s=(char *)malloc(MAX_COMP_LEN * sizeof(char));
	while(p[i++] != '=')
	  ;
	while(p[i]==' ')   //去除空格
	    i++;
	while(p[i] != ';' && p[i] != '\n' && p[i] != '\r')
	  if(p[i]!=' ')
		s[j++]=p[i++];
	  else
		i++;
	s[j]='\0';
	return s;

}
char *jump(char p[])
{
	int i=1,j=0;
	char *s=(char *)malloc(MAX_JUMP_LEN * sizeof(char));
	char *tmp=strchr(p,';');
	if(tmp!=NULL){
	  while(tmp[i]!='\n')
		if(tmp[i]!=' ')
		  s[j++]=tmp[i++];
		else
		  i++;
	  s[j]='\0';
	}
	else
	  strcpy(s,"null");
	return s;
	
}
int parser(char in_path[], char out_path[], HashTable *list)
{
	char s[MAX_LEN];
	char code_s[MAX_CODE_LEN+1];
	code_s[0]=0;
	COMMAND_TYPE type;
	FILE *file=NULL,*file1=NULL;
	file=fopen(in_path,"r");
	file1=fopen(out_path,"a+");
	if(file==NULL||file1==NULL){
		printf("open fail");
		return -1;
	}
	while(fgets(s,MAX_LEN,file)!=NULL){
		type=commandType(s);
		switch(type){
			case A_COMMAND:
				code_a_command(s,code_s,list);
				fputs(code_s,file1);
				code_s[0]=0;
				break;
			case C_COMMAND:
				code_c_command(s,code_s);
				fputs(code_s,file1);
				code_s[0]=0;
				break;
			case L_COMMAND:
				break;
			case ANNOTATION:
				break;
		}
	}
	fclose(file);
	fclose(file1);
	return 1;
}
int  built_symbol_list(char path[], HashTable *list)
{
	int real_line=0;
	FILE *file=NULL;
	if((file=fopen(path,"r"))==NULL)
	  return -1;
	char s[MAX_LEN],address[MAX_CODE_LEN-1];
	COMMAND_TYPE type;
	memset(s, '\0', sizeof(address)-1);
	memset(address, '\0', sizeof(address)-1);
	while(fgets(s,MAX_LEN,file)!=NULL){
			type=commandType(s);
		switch(type){
			case A_COMMAND:
				real_line++;
				break;
			case C_COMMAND:
				real_line++;
				break;
			case L_COMMAND:
				if(hash_exists(list,symbol(s))==EXISTS){
                   translate(real_line,address);
				   hash_add(list,symbol(s),address);
				}
			case ANNOTATION:
				break;
		}
	memset(s, '\0', sizeof(address)-1);
	memset(address, '\0', sizeof(address)-1);

	}
}
int main(int argc, char *argv[])
{
    HashTable *list = create_hashtable(15,char *,char*);
	printf("%s\n",argv[1]);
	printf("%s\n",argv[2]);
	built_symbol_list(argv[1],list);
	if(parser(argv[1],argv[2],list)==-1)
	  printf("error");
	hash_free(list);
	return  0;
}
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include "parser.h"
#include "hashtable.h"

char *DEST[]={"null","M","D","MD","A","AM","AD","AMD"};
char *CODE_DEST[]={"000","001","010","011","100","101","110","111"};
char *JUMP[]={"null","JGT","JEQ","JGE","JLT","JNE","JLE","JMP"};
char *CODE_JUMP[]={"000","001","010","011","100","101","110","111"};
char *COMP[]={"0","1","-1","D","A","!D","!A","-D","-A","D+1","A+1","D-1","A-1","D+A","D-A","A-D","D&A","D|A","M","!M","-M","M+1","M-1","D+M","D-M","M_D","D&M","D|M"};
char *CODE_COMP[]={"0101010","0111111","0111010","0001100","0110000","0001101","0110001","0001111","0110011","0011111","0110111","0001110","0110010","0000010","0010011","0000111","0000000","010101","1110000","1110001","1110011","1110111","1110010","1000010","1010011","1000111","1000000","1010101"};

void code_dest(char p[],char code[])
{
	int i=0;
	while(strcmp(p,*(DEST+i))!=0)
	  i++;
	strcat(code,*(CODE_DEST+i));
     
}
void code_jump(char p[],char code[])
{
	int i=0;
	while(strcmp(p,*(JUMP+i))!=0)
	  i++;
	strcat(code,*(CODE_JUMP+i));
}
void code_comp(char p[],char code[])
{
	int i=0;
	while(strcmp(p,*(COMP+i))!=0)
	  i++;
	strcat(code,*(CODE_COMP+i));

}
void code_a_command(char source[], char code[], HashTable *list)
{
	char *temp;
	strcat(code,"0");
	if(is_number(symbol(source)))
	  strcat(code,symbol(source));
	else{
	  hash_find(list,symbol(source),&temp);
	  strcat(code,temp);
	}
	code[MAX_CODE_LEN]='\n';
	code[MAX_CODE_LEN+1]='\0';
    
}
void code_c_command(char source[], char code[])
{
	strcat(code,"111");
	code_comp((comp(source)),code);
	code_dest((dest(source)),code);
	code_jump((jump(source)),code);
	code[MAX_CODE_LEN]='\n';
	code[MAX_CODE_LEN+1]='\0';
}
